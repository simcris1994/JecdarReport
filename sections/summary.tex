\chapter*{Summary\markboth{Summary}{Summary}}\label{ch:summary}

The idea of this project revolves around the field of model-checking tools that are used to automate the process of verification and validation of certain properties for models defined with an automata-based language. One of the prominent examples of such tools is \uppaal \footnote{\textcite{uppaal-nutshell}}. Starting from 1995 and until now it has developed into a large family of tools containing multiple branches, with \textsc{Uppaal Stratego}\footnote{\textcite{uppaalStratego}} being the latest one. 

In particular, the branch of \uppaal called \ecdar\footnote{\textcite{ecdar010}} became the subject of interest. This tool operates with models that are based on the theory of Timed Input/Output Automata\footnote{\textcite{David:2010}} (TIOA). Being a specification theory, it supports various features including \textit{refinement, composition, conjunction} and \textit{quotient}, as well as various checks including \textit{determinism, consistency} and \textit{implementation}. 

However, all the \uppaal tools are only available freely for academia related purposes. Therefore, the goal for the two-semester Master's project became the development of a new open source model-checking engine that operates with the same models and supports the same features as the existing \ecdar 0.10 tool. This involves familiarizing with existing theories, designing and implementing a new Java Engine for Compositional Design and Analysis of Real-time systems (\jecdar).

In this project we continue the development of \jecdar, which is the result of work done by Kiviriga, Klicius and Simionescu\footnote{\textcite{Jecdar:2019}} during the 9\textsuperscript{th} semester. At the start of this project the existing features of \jecdar included \textit{refinement, composition and conjunction}, setting our goal to continue the implementation of the remaining features and checks.

Unexpectedly, soon in the semester two main issues were discovered that drastically changed the direction of the project. First of all, despite the assumed correctness of the implemented features, some state-space exploration problems were found in \jecdar during verification of refinement feature. This led to extensive manual testing of various models in \ecdar 0.10 to verify the correctness of our assumptions regarding the outcome of queries. Second of all, we previously assumed \ecdar 0.10 to contain no issues and all the feature verification results of \jecdar were compared to \ecdar 0.10 to ensure correctness. However we have also discovered a number of inconsistencies between its implementation and theory, which forced us to investigate the issue further. The discovery, understanding and documentation of these issues became the main goal of the project, as only this way would we be able to guarantee correctness by solving these issues.

To combat the discovered issues and come up with the correct solution we propose a number of concepts, each of which is meant to solve a specific problem. Some of these concepts end up being not suitable, but become a ground for new ones, finally leading to the discovery of an approach that ensures correct refinement verification. This allows us to implement the possibility to return the non-canonical refinement relation.

In addition to that, we implement \textit{determinism, least fixpoint consistency, full consistency} and \textit{implementation} checks in \jecdar. To verify the correctness of all the features we use the test suite that includes a big number of corner cases which were found during the inconsistencies discovery phase. Both code coverage and branch coverage testing is performed to ensure correctness, with nearly a hundred percent coverage.

The development done for \jecdar 0.2 is a great step towards having an open source model-checking engine with the functionality of that similar to \ecdar 0.10, where the former does not exhibit the same inconsistencies with the theory as the latter one. Nonetheless, there is a lot of room for improvements. This could include implementation of new features, use of abstraction techniques, performance optimization of the code, introduction of new modules supporting different automata theories and more.

\newpage